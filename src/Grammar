<program>  -->  <moduleDeclarations> <otherModules><driverModule><otherModules>

<moduleDeclarations> -->  <moduleDeclaration><moduleDeclarations> | ε

<moduleDeclaration>  -->  DECLARE MODULE ID SEMICOL

<otherModules> -->  <module><otherModules>| ε

<driverModule> --> DRIVERDEF DRIVER PROGRAM DRIVERENDDEF <moduleDef>

<module> -->  DEF MODULE ID ENDDEF TAKES INPUT SQBO <input_plist> SQBC SEMICOL <ret> <moduleDef>

<ret> -->  RETURNS SQBO <output_plist> SQBC SEMICOL | ε

<input_plist> -->  ID COLON <dataType>  <M>
<M> --> COMMA ID COLON <dataType> <M>|ε

<output_plist> -->  ID COLON <type> <M1>
<M1> --> COMMA ID COLON <type> <M1>|ε

<dataType> -->  INTEGER | REAL | BOOLEAN 
		| ARRAY SQBO <range> SQBC OF <type>

<type> -->  INTEGER | REAL | BOOLEAN

<moduleDef> -->  START <statements> END

<statements> --> <statement> <statements> | ε

<statement> --> <ioStmt>
		|<simpleStmt>
		|<declareStmt>
		|<condionalStmt>
		|<iterativeStmt>

<ioStmt> --> GET_VALUE BO ID BC SEMICOL 
	     | PRINT BO <var> BC SEMICOL

<var> -->  ID <whichId> | NUM | RNUM

<whichId> -->  SQBO <index> SQBC | ε   //changed to <index> to allow
				       //for numbers in ar indexing.

<simpleStmt> -->  <assignmentStmt> | <moduleReuseStmt>

<assignmentStmt>  -->  ID <whichStmt>

<whichStmt> --> <lvalueIDStmt> | <lvalueARRStmt>

<lvalueIDStmt> -->  ASSIGNOP <expression> SEMICOL

<lvalueARRStmt>  -->  SQBO <index> SQBC ASSIGNOP <expression> SEMICOL

<index> -->  NUM | ID

<moduleReuseStmt>  --> <optional> USE MODULE ID WITH PARAMETERS <idList>SEMICOL

<optional> -->  SQBO <idList> SQBC ASSIGNOP | ε

<idList> --> ID<L>
<L> -->  COMMA ID <L>|ε



//First set of arithmeticExpr and booleanExpr was same.
// Therefore modify rules to make LL(1).
 
<expression> --> <arithBoolExpr>
		| MINUS BO <arithmeticExpr> BC
		| PLUS BO <arithmeticExpr> BC

<arithBoolExpr> --> <select><N>
		| BO <arithBoolExpr> BC

<N> --> <logicalOp> <select> <N>|ε

<select> --> <arithmeticExpr><N1>

<N1> --> <relationalOp> <arithmeticExpr><N1>|ε


<arithmeticExpr> --> <term> <K>
<K> --> <addOp> <term><K>| e      //handling precedence and 
				  //removing left recursion

<term> --> <factor><R>              
<R> --> <mulOp><factor> <R>|ε	    //handling precedence and
				    //removing left recursion

<factor> --> BO <arithmeticExpr> BC
<factor> --> <var> 

<addOp> -->  PLUS | MINUS           //split in to two Ops to handle precedence
<mulOp> -->  MUL | DIV

<logicalOp> --> AND | OR

<relationalOp> -->  LT | LE | GT | GE | EQ | NE

<declareStmt> -->  DECLARE <idList> COLON <dataType> SEMICOL

<condionalStmt> --> SWITCH BO ID BC START <caseStmt><default> END

<caseStmt> -> CASE <value> COLON <statements> BREAK SEMICOL <X1>   
<X1> -> CASE <value> COLON <statements> BREAK SEMICOL <X1> | ε	    // rule modified to make sure atleast
								    // one case statement is present

<value> --> NUM | TRUE | FALSE

<default> --> DEFAULT COLON <statements> BREAK SEMICOL | ε

<iterativeStmt> --> FOR BO ID IN <range> BC START <statements> END
		    | WHILE BO <arithBoolExpr> BC START <statements> END

<range> --> NUM RANGEOP NUM 
	    | ID RANGEOP ID 
