<program>  -->  <moduleDeclarations> <otherModules><driverModule><otherModules>

<moduleDeclarations> -->  <moduleDeclaration><moduleDeclarations> | ε

<moduleDeclaration>  -->  DECLARE MODULE ID SEMICOL

<otherModules> -->  <module><otherModules>| ε

<driverModule> -->  DEF DRIVER PROGRAM ENDDEF <moduleDef>

<module> -->  DEF MODULE ID ENDDEF TAKES INPUT SQBO <input_plist> SQBC SEMICOL <ret> <moduleDef>

<ret> -->  RETURNS SQBO <output_plist> SQBC SEMICOL | ε

<input_plist> -->  ID COLON <dataType>  <M>
<M> --> COMMA ID COLON <dataType> <M>|ε

<output_plist> -->  ID COLON <type> <M1>
<M1> --> COMMA ID COLON <type> <M1>|ε

<dataType> -->  INTEGER | REAL | BOOLEAN | ARRAY SQBO <range> SQBC OF <type>

<type> -->  INTEGER | REAL | BOOLEAN

<moduleDef> -->  START <statements> END

<statements> --> <statement> <statements> | ε

<statement> --> <ioStmt>|<simpleStmt>|<declareStmt>|<condionalStmt>|<iterativeStmt>

<ioStmt> --> GET_VALUE BO ID BC SEMICOL | PRINT BO <var> BC SEMICOL

<var> -->  ID <whichId> | NUM | RNUM

<whichId> -->  SQBO <index> SQBC | ε   //changed to <index> to allow f					     //or numbers in ar indexing.

<simpleStmt> -->  <assignmentStmt> | <moduleReuseStmt>

<assignmentStmt>  -->  ID <whichStmt>

<whichStmt> --> <lvalueIDStmt> | <lvalueARRStmt>

<lvalueIDStmt> -->  ASSIGNOP <expression> SEMICOL

<lvalueARRStmt>  -->  SQBO <index> SQBC ASSIGNOP <expression> SEMICOL

<index> -->  NUM | ID

<moduleReuseStmt>  --> <optional> USE MODULE ID WITH PARAMETERS <idList>SEMICOL

<optional> -->  SQBO <idList> SQBC ASSIGNOP | ε

<idList> --> ID<L>
<L> -->  COMMA ID <L>|ε



//First set of arithmeticExpr and booleanExpr was same.
// Therefore modify rules to make LL(1). 
<expression> --> <arithBoolExpr>

<arithBoolExpr> --> <select><N>| BO <arithBoolExpr> BC
<N> --> <logicalOp> <select> <N>|ε
<select> --> <arithmeticExpr><N1>
<N1> --> <relationalOp> <arithmeticExpr><N1>|ε


<arithmeticExpr> --> <term> <K>
<K> --> <addOp> <term><K>| e      //handling precedence and 
				    //removing left recursion

<term> --> <factor><R>              
<R> --> <mulOp><factor> <R>|ε	    //handling precedence and
				    //removing left recursion

<factor> --> <var> // BO precedence included above

<addOp> -->  PLUS | MINUS           //precedence
<mulOp> -->  MUL | DIV

<logicalOp> --> AND | OR

<relationalOp> -->  LT | LE | GT | GE | EQ | NE

<declareStmt> -->  DECLARE <idList> COLON <dataType> SEMICOL

<condionalStmt> --> SWITCH BO ID BC START <caseStmt><default> END

<caseStmt> --> CASE <value> COLON <statements> BREAK SEMICOL <caseStmt>

<value> --> NUM | TRUE | FALSE

<default> --> DEFAULT COLON <statements> BREAK SEMICOL | ε

<iterativeStmt> --> FOR BO ID IN <range> BC START <statements> END |WHILE BO <booleanExpr> BC START <statements> END

<range> --> NUM RANGEOP NUM
